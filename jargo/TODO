Introduce companion library with DateParser etc in
Usage: sort with collator?
    Collator collator = Collator.getInstance(locale);
    collator.getCollationKey(source)
    Collections.sort(aWords, collator);
Deploy javadoc to gh-pages automatically when release is performed, execute:
    git clone https://github.com/Softhouse/jargo.git jargo-gh-pages
    cd jargo-gh-pages/
    git checkout --orphan gh-pages
    rm -r javadoc/jargo/*
    rm -r javadoc/common-test/*
    cp -r ../jargo/jargo/target/site/apidocs/ javadoc/jargo/
    cp -r ../jargo/common-test/target/site/apidocs/ javadoc/common-test/
    git add -u && git commit -m "Updated javadocs" && git push origin gh-pages

Features:

Usage#includeOneLinerInUsage() - Print one line with all options
   Before serializing ArgumentException this string will have to be calculated

CommandLineParser#interactiveMode() - For failed arguments offer an option to correct them
 * should required arguments be handled by this always?
 * What about clients that don't have a console? Default to throw? Opt-in-feature.
 * think about Multiple Occurrences (ask Do you want to enter one more value for [-s] (y/N):
 * Can auto complete be provided?
 * Repeat reading for invalid values

ArgumentFactory#helpArgument() - "-h", "--help" print usage, alternatively take an argument/command and describe only that

DefaultArgumentBuilder<T> Arguments#withFunction(Function<String, T> stringParser)
    How to require a choice between required() and defaultValue(), meta description?

ICommand, interface version of Command that's simpler and doesn't support arguments
   Issues: the name isn't very clear and will people confuse it with Command?

ArgumentBuilder#withAction(Callable<T> actionToPerformForParsedValues) - This would be exactly like the old "Callback" feature, Could avoid a lot of if statements
...Issues: Should ForwardingStringParser be recommended instead?
           ArgumentFactory#option(...) can't be decorated...

ArgumentBuilder#tabCompleter(Function<String, Iterable<String>> tabCompleterFunction)
   CommandLineParser#tabComplete(String... currentArguments) - where the last argument will be the
                                                                input to the tabCompleterFunction for the last matching argument
        tabCompleterFunction a function that given a starting string returns an {@link Iterable} of strings that could complete that string into a valid argument
ArgumentBuilder#readPassword() - Read argument from Console, ensures that nobody can see the password by looking at process arguments

ArgumentBuilder#incompatibleWith(Argument<?> ... otherArguments)

ArgumentBuilder#transformWith(Function<F, T> function)
        runs function.apply(parsedValue) so that Argument<F> switches type to Argument<T> such a function would be extremely
        reusable in other scenarios as well, i.e convert this list of integers to Port objects
        How should limiters be called? If they are called before function.apply(), what if it's modifiable and the limiter may change the value?

ArgumentException#getLocalizedMessage(Locale locale)

CommandLineParserInstance#getDefinitionForCurrentArgument - if one argument can be singled out choose it,
        for instance git upd for git update as no other command starts with upd, think about command arguments: git upd --ind, should --index be assumed
